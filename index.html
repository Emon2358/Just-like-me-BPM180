<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automatic MP3 BPM Adjuster</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 500px;
            text-align: center;
        }
        h1 {
            color: #1a73e8;
            margin-bottom: 25px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: left;
        }
        input[type="file"] {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 6px;
            border: 1px solid #ddd;
            cursor: pointer;
            background-color: #f9f9f9;
        }
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
        }
        button:hover {
            background-color: #155ab6;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .bpm-info {
            background-color: #e8f0fe;
            border-left: 5px solid #1a73e8;
            padding: 15px;
            margin-bottom: 20px;
            text-align: left;
            border-radius: 5px;
        }
        .bpm-info p {
            margin: 0;
            font-size: 1.1em;
        }
        .bpm-info strong {
            font-size: 1.4em;
            color: #1a73e8;
        }
        .bpm-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .bpm-controls input[type="range"] {
            flex-grow: 1;
        }
        .bpm-controls input[type="number"] {
            width: 80px;
        }
        #status {
            margin-top: 20px;
            color: #555;
            min-height: 20px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Automatic BPM Adjuster ğŸ¶</h1>

    <div class="control-group">
        <label for="file-input">1. MP3ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
        <input type="file" id="file-input" accept=".mp3">
    </div>

    <div id="bpm-info-container" class="bpm-info" style="display: none;">
        <p>è§£æã•ã‚ŒãŸBPM: <strong id="detected-bpm-display">...</strong></p>
    </div>

    <div class="control-group">
        <label for="bpm-slider">2. BPMã‚’èª¿æ•´</label>
        <div class="bpm-controls">
            <input type="range" id="bpm-slider" min="50" max="200" value="120" disabled>
            <input type="number" id="bpm-input" min="50" max="200" value="120" disabled>
        </div>
    </div>

    <div class="control-group">
        <button id="play-pause-button" disabled>å†ç”Ÿ</button>
        <button id="download-button" disabled>WAVå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
    </div>

    <p id="status"></p>
</div>

<script>
    // --- DOMè¦ç´ ã®å–å¾— ---
    const fileInput = document.getElementById('file-input');
    const bpmSlider = document.getElementById('bpm-slider');
    const bpmInput = document.getElementById('bpm-input');
    const detectedBpmDisplay = document.getElementById('detected-bpm-display');
    const bpmInfoContainer = document.getElementById('bpm-info-container');
    const playPauseButton = document.getElementById('play-pause-button');
    const downloadButton = document.getElementById('download-button');
    const status = document.getElementById('status');

    // --- Web Audio APIã®åˆæœŸåŒ– ---
    let audioContext;
    let audioBuffer;
    let sourceNode;
    let isPlaying = false;
    let originalBpm = 0;

    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
    fileInput.addEventListener('change', handleFileSelect);
    bpmSlider.addEventListener('input', syncBpmInputs);
    bpmInput.addEventListener('input', syncBpmInputs);
    playPauseButton.addEventListener('click', togglePlayback);
    downloadButton.addEventListener('click', downloadAdjustedAudio);

    // --- æ©Ÿèƒ½ã®æœ‰åŠ¹/ç„¡åŠ¹åŒ– ---
    function updateControlsState(isReady) {
        bpmSlider.disabled = !isReady;
        bpmInput.disabled = !isReady;
        playPauseButton.disabled = !isReady;
        downloadButton.disabled = !isReady;
    }

    // --- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚ã®å‡¦ç† ---
    async function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        updateControlsState(false);
        bpmInfoContainer.style.display = 'none';
        status.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ä¸­...';

        try {
            const arrayBuffer = await file.arrayBuffer();
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            status.textContent = 'BPMã‚’è§£æä¸­... (æ›²ã®é•·ã•ã«ã‚ˆã‚Šæ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™)';
            // BPMè§£æå‡¦ç†ã‚’å°‘ã—é…å»¶ã•ã›ã¦UIã®æ›´æ–°ã‚’ç¢ºå®Ÿã«è¡Œã†
            setTimeout(async () => {
                const detectedBpm = await analyzeBpm(audioBuffer);
                originalBpm = detectedBpm;

                detectedBpmDisplay.textContent = Math.round(originalBpm * 10) / 10;
                bpmInfoContainer.style.display = 'block';

                // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ç­‰ã®ç¯„å›²ã¨ç¾åœ¨å€¤ã‚’æ›´æ–°
                const baseBpm = Math.round(originalBpm);
                bpmSlider.min = Math.floor(baseBpm * 0.5);
                bpmSlider.max = Math.ceil(baseBpm * 2);
                bpmInput.min = Math.floor(baseBpm * 0.5);
                bpmInput.max = Math.ceil(baseBpm * 2);
                bpmSlider.value = baseBpm;
                bpmInput.value = baseBpm;
                
                status.textContent = 'æº–å‚™ãŒã§ãã¾ã—ãŸã€‚';
                updateControlsState(true);
            }, 100);

        } catch (error) {
            status.textContent = 'ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
            console.error(error);
            audioBuffer = null;
        }
    }

    // --- BPMã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›æ¬„ã®åŒæœŸãƒ»å†ç”Ÿãƒ¬ãƒ¼ãƒˆæ›´æ–° ---
    function syncBpmInputs(event) {
        const newBpm = event.target.value;
        bpmSlider.value = newBpm;
        bpmInput.value = newBpm;
        updatePlaybackRate();
    }
    
    function updatePlaybackRate() {
        if (isPlaying && sourceNode && originalBpm > 0) {
            const newBpm = parseFloat(bpmInput.value);
            sourceNode.playbackRate.value = newBpm / originalBpm;
        }
    }

    // --- å†ç”Ÿ/åœæ­¢ ---
    function togglePlayback() {
        if (isPlaying) {
            stopSound();
        } else {
            playSound();
        }
    }

    function playSound() {
        if (!audioBuffer || !audioContext) return;
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.connect(audioContext.destination);
        sourceNode.onended = () => {
            if (isPlaying) stopSound();
        };
        updatePlaybackRate(); // å†ç”Ÿé–‹å§‹å‰ã«ãƒ¬ãƒ¼ãƒˆã‚’è¨­å®š
        sourceNode.start(0);
        isPlaying = true;
        playPauseButton.textContent = 'åœæ­¢';
    }

    function stopSound() {
        if (sourceNode) {
            sourceNode.stop();
            sourceNode.disconnect();
            sourceNode = null;
        }
        isPlaying = false;
        playPauseButton.textContent = 'å†ç”Ÿ';
    }

    // --- BPMè§£æ ---
    async function analyzeBpm(audioBuffer) {
        // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’é«˜é€Ÿå‡¦ç†
        const offlineCtx = new OfflineAudioContext(1, audioBuffer.length, audioBuffer.sampleRate);
        const source = offlineCtx.createBufferSource();
        source.buffer = audioBuffer;

        // ãƒ“ãƒ¼ãƒˆãŒè±Šå¯Œãªä½å‘¨æ³¢å¸¯ã‚’æŠ½å‡ºã™ã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
        const filter = offlineCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 150; // Hz
        filter.Q.value = 1;

        source.connect(filter);
        filter.connect(offlineCtx.destination);
        source.start(0);

        const processedBuffer = await offlineCtx.startRendering();
        const data = processedBuffer.getChannelData(0);
        
        // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®ãƒ”ãƒ¼ã‚¯ï¼ˆãƒ“ãƒ¼ãƒˆï¼‰ã‚’æ¤œå‡º
        const peaks = getPeaks(data, audioBuffer.sampleRate);
        if (peaks.length < 2) return 120; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤

        // ãƒ”ãƒ¼ã‚¯é–“ã®é–“éš”ã‚’åˆ†æ
        const intervals = getIntervals(peaks);
        
        // æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„BPMã‚’ç‰¹å®š
        const topBpm = getTopBpm(intervals, audioBuffer.sampleRate);

        return topBpm.bpm;
    }

    function getPeaks(data, sampleRate) {
        const peaks = [];
        const threshold = 0.6; // ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã®é–¾å€¤
        for (let i = 1; i < data.length - 1; i++) {
            if (data[i] > data[i - 1] && data[i] > data[i + 1] && data[i] > threshold) {
                peaks.push(i);
            }
        }
        return peaks;
    }

    function getIntervals(peaks) {
        const intervals = [];
        for (let i = 0; i < peaks.length - 1; i++) {
            intervals.push(peaks[i + 1] - peaks[i]);
        }
        return intervals;
    }

    function getTopBpm(intervals, sampleRate) {
        const intervalCounts = {};
        intervals.forEach(interval => {
            // BPMã®å€™è£œã‚’è¨ˆç®— (60ç§’ / (ã‚µãƒ³ãƒ—ãƒ«é–“éš” / ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ))
            const theoreticalBpm = 60 / (interval / sampleRate);
            
            // BPMã‚’å¦¥å½“ãªç¯„å›²(70-180)ã«ä¸¸ã‚è¾¼ã‚€
            let roundedBpm = Math.round(theoreticalBpm);
            while(roundedBpm < 70) roundedBpm *= 2;
            while(roundedBpm > 180) roundedBpm /= 2;
            roundedBpm = Math.round(roundedBpm);

            intervalCounts[roundedBpm] = (intervalCounts[roundedBpm] || 0) + 1;
        });

        // æœ€ã‚‚é »å‡ºã™ã‚‹BPMã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¦‹ã¤ã‘ã‚‹
        let topBpm = { bpm: 120, count: 0 };
        for (const bpm in intervalCounts) {
            if (intervalCounts[bpm] > topBpm.count) {
                topBpm = { bpm: parseFloat(bpm), count: intervalCounts[bpm] };
            }
        }
        return topBpm;
    }
    
    // --- ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç† (å¤‰æ›´ãªã—) ---
    async function downloadAdjustedAudio() {
        if (!audioBuffer || !originalBpm) {
            alert('ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
            return;
        }
        
        status.textContent = 'éŸ³æºã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­...ã“ã‚Œã«ã¯æ•°ç§’ã‹ã‹ã‚Šã¾ã™ã€‚';
        downloadButton.disabled = true;

        try {
            const newBpm = parseFloat(bpmInput.value);
            const playbackRate = newBpm / originalBpm;
            
            const offlineContext = new OfflineAudioContext(
                audioBuffer.numberOfChannels,
                Math.ceil(audioBuffer.length / playbackRate), // å†ç”Ÿé€Ÿåº¦ã«åˆã‚ã›ã¦é•·ã•ã‚’èª¿æ•´
                audioBuffer.sampleRate
            );

            const offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = audioBuffer;
            offlineSource.playbackRate.value = playbackRate;
            offlineSource.connect(offlineContext.destination);
            offlineSource.start(0);

            const renderedBuffer = await offlineContext.startRendering();
            const wavBlob = bufferToWav(renderedBuffer);

            const url = URL.createObjectURL(wavBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `adjusted_bpm_${newBpm}.wav`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            status.textContent = 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸã€‚';
        } catch(e) {
            status.textContent = 'ã‚¨ãƒ©ãƒ¼: éŸ³æºã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
            console.error(e);
        } finally {
            downloadButton.disabled = false;
        }
    }

    function bufferToWav(buffer) {
        const numOfChan = buffer.numberOfChannels;
        const length = buffer.length * numOfChan * 2 + 44;
        const bufferArr = new ArrayBuffer(length);
        const view = new DataView(bufferArr);
        const channels = [];
        let i, sample;
        let offset = 0, pos = 0;
        
        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8);
        setUint32(0x45564157); // "WAVE"
        setUint32(0x20746d66); // "fmt "
        setUint32(16);
        setUint16(1);
        setUint16(numOfChan);
        setUint32(buffer.sampleRate);
        setUint32(buffer.sampleRate * 2 * numOfChan);
        setUint16(numOfChan * 2);
        setUint16(16);
        setUint32(0x61746164); // "data"
        setUint32(length - pos - 4);

        for (i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));

        while (pos < length) {
            for (i = 0; i < numOfChan; i++) {
                sample = Math.max(-1, Math.min(1, channels[i][offset]));
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
            offset++;
        }
        return new Blob([view], { type: 'audio/wav' });
    }

</script>
</body>
</html>
