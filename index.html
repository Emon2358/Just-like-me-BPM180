<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3 BPM Adjuster</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 500px;
            text-align: center;
        }
        h1 {
            color: #1a73e8;
            margin-bottom: 25px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: left;
        }
        input[type="file"], input[type="number"], input[type="range"] {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        input[type="file"] {
            cursor: pointer;
            background-color: #f9f9f9;
        }
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
        }
        button:hover {
            background-color: #155ab6;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .bpm-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .bpm-controls input[type="range"] {
            flex-grow: 1;
        }
        .bpm-controls input[type="number"] {
            width: 80px;
        }
        #bpm-display {
            font-size: 1.2em;
            font-weight: bold;
            color: #1a73e8;
        }
        #status {
            margin-top: 20px;
            color: #555;
            min-height: 20px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>MP3 BPM Adjuster 🎧</h1>

    <div class="control-group">
        <label for="file-input">1. MP3ファイルを選択</label>
        <input type="file" id="file-input" accept=".mp3">
    </div>

    <div class="control-group">
        <label for="original-bpm">2. 元のBPMを入力</label>
        <input type="number" id="original-bpm" placeholder="例: 128" min="30" max="300">
    </div>

    <div class="control-group">
        <label>3. BPMを調整</label>
        <div class="bpm-controls">
            <input type="range" id="bpm-slider" min="50" max="200" value="128" disabled>
            <input type="number" id="bpm-input" min="50" max="200" value="128" disabled>
        </div>
        <p>現在のBPM: <span id="bpm-display">128</span></p>
    </div>

    <div class="control-group">
        <button id="play-pause-button" disabled>再生</button>
        <button id="download-button" disabled>WAV形式でダウンロード</button>
    </div>

    <p id="status"></p>
</div>

<script>
    // --- DOM要素の取得 ---
    const fileInput = document.getElementById('file-input');
    const originalBpmInput = document.getElementById('original-bpm');
    const bpmSlider = document.getElementById('bpm-slider');
    const bpmInput = document.getElementById('bpm-input');
    const bpmDisplay = document.getElementById('bpm-display');
    const playPauseButton = document.getElementById('play-pause-button');
    const downloadButton = document.getElementById('download-button');
    const status = document.getElementById('status');

    // --- Web Audio APIの初期化 ---
    let audioContext;
    let audioBuffer;
    let sourceNode;
    let isPlaying = false;
    let originalBpm = 0;

    // --- イベントリスナー ---
    fileInput.addEventListener('change', handleFileSelect);
    originalBpmInput.addEventListener('input', handleBpmInput);
    bpmSlider.addEventListener('input', syncBpmInputs);
    bpmInput.addEventListener('input', syncBpmInputs);
    playPauseButton.addEventListener('click', togglePlayback);
    downloadButton.addEventListener('click', downloadAdjustedAudio);

    // --- 機能の有効/無効化 ---
    function updateControlsState() {
        const isReady = audioBuffer && originalBpm > 0;
        bpmSlider.disabled = !isReady;
        bpmInput.disabled = !isReady;
        playPauseButton.disabled = !isReady;
        downloadButton.disabled = !isReady;
    }

    // --- ファイル選択時の処理 ---
    async function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        // AudioContextはユーザー操作後に初期化する
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        status.textContent = 'ファイルをデコード中...';
        playPauseButton.disabled = true;
        downloadButton.disabled = true;

        try {
            const arrayBuffer = await file.arrayBuffer();
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            status.textContent = 'ファイルの準備ができました。';
        } catch (error) {
            status.textContent = 'エラー: ファイルのデコードに失敗しました。';
            console.error(error);
            audioBuffer = null;
        }
        updateControlsState();
    }

    // --- 元のBPM入力時の処理 ---
    function handleBpmInput(event) {
        originalBpm = parseFloat(event.target.value) || 0;
        // スライダーと入力欄の範囲も更新
        const baseBpm = originalBpm > 0 ? originalBpm : 128;
        bpmSlider.min = Math.floor(baseBpm * 0.5);
        bpmSlider.max = Math.ceil(baseBpm * 2);
        bpmInput.min = Math.floor(baseBpm * 0.5);
        bpmInput.max = Math.ceil(baseBpm * 2);
        // 現在値を元のBPMにリセット
        bpmSlider.value = baseBpm;
        bpmInput.value = baseBpm;
        bpmDisplay.textContent = baseBpm;
        updateControlsState();
    }

    // --- BPMスライダーと入力欄の同期・再生レート更新 ---
    function syncBpmInputs(event) {
        const newBpm = event.target.value;
        bpmSlider.value = newBpm;
        bpmInput.value = newBpm;
        bpmDisplay.textContent = newBpm;
        updatePlaybackRate();
    }
    
    function updatePlaybackRate() {
        if (!isPlaying || !sourceNode || !originalBpm) return;
        const newBpm = parseFloat(bpmInput.value);
        sourceNode.playbackRate.value = newBpm / originalBpm;
    }

    // --- 再生/停止の切り替え ---
    function togglePlayback() {
        if (isPlaying) {
            stopSound();
        } else {
            playSound();
        }
    }

    function playSound() {
        if (!audioBuffer || !audioContext) return;
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = audioBuffer;
        updatePlaybackRate();
        sourceNode.connect(audioContext.destination);
        sourceNode.onended = () => {
            stopSound();
        };
        sourceNode.start(0);
        isPlaying = true;
        playPauseButton.textContent = '停止';
    }

    function stopSound() {
        if (sourceNode) {
            sourceNode.stop();
            sourceNode.disconnect();
            sourceNode = null;
        }
        isPlaying = false;
        playPauseButton.textContent = '再生';
    }

    // --- 調整後音源のダウンロード処理 ---
    async function downloadAdjustedAudio() {
        if (!audioBuffer || !originalBpm) {
            alert('オーディオファイルと元のBPMが設定されていません。');
            return;
        }
        
        status.textContent = '音源をレンダリング中...これには数秒かかります。';
        downloadButton.disabled = true;

        try {
            const newBpm = parseFloat(bpmInput.value);
            const playbackRate = newBpm / originalBpm;
            
            // OfflineAudioContextでエフェクト（再生速度の変更）を適用
            const offlineContext = new OfflineAudioContext(
                audioBuffer.numberOfChannels,
                audioBuffer.length,
                audioBuffer.sampleRate
            );

            const offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = audioBuffer;
            offlineSource.playbackRate.value = playbackRate;
            offlineSource.connect(offlineContext.destination);
            offlineSource.start(0);

            const renderedBuffer = await offlineContext.startRendering();
            
            // レンダリングされたバッファをWAVに変換
            const wavBlob = bufferToWav(renderedBuffer);

            // ダウンロードリンクを作成してクリック
            const url = URL.createObjectURL(wavBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `adjusted_bpm_${newBpm}.wav`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            status.textContent = 'ダウンロードが完了しました。';
        } catch(e) {
            status.textContent = 'エラー: 音源の生成に失敗しました。';
            console.error(e);
        } finally {
            downloadButton.disabled = false;
        }
    }

    // --- AudioBufferをWAV Blobに変換する関数 ---
    function bufferToWav(buffer) {
        const numOfChan = buffer.numberOfChannels;
        const length = buffer.length * numOfChan * 2 + 44;
        const bufferArr = new ArrayBuffer(length);
        const view = new DataView(bufferArr);
        const channels = [];
        let i, sample;
        let offset = 0;
        let pos = 0;

        // ヘッダを書き込む
        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8); // file length - 8
        setUint32(0x45564157); // "WAVE"
        setUint32(0x20746d66); // "fmt " chunk
        setUint32(16); // length = 16
        setUint16(1); // PCM (uncompressed)
        setUint16(numOfChan);
        setUint32(buffer.sampleRate);
        setUint32(buffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
        setUint16(numOfChan * 2); // block-align
        setUint16(16); // 16-bit
        setUint32(0x61746164); // "data" - chunk
        setUint32(length - pos - 4); // chunk length

        function setUint16(data) {
            view.setUint16(pos, data, true);
            pos += 2;
        }
        function setUint32(data) {
            view.setUint32(pos, data, true);
            pos += 4;
        }

        // PCMデータを書き込む
        for (i = 0; i < numOfChan; i++) {
            channels.push(buffer.getChannelData(i));
        }

        while (pos < length) {
            for (i = 0; i < numOfChan; i++) {
                sample = Math.max(-1, Math.min(1, channels[i][offset]));
                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
            offset++;
        }

        return new Blob([view], { type: 'audio/wav' });
    }

</script>
</body>
</html>
