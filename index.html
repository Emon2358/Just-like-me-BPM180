<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Web DJ Console</title>
    <style>
        :root {
            --bg-color: #1a1d22;
            --deck-color: #24282f;
            --playlist-color: #2a2e36;
            --text-light: #e6e6e6;
            --text-muted: #8c92a4;
            --accent-blue: #00aeff;
            --accent-green: #4caf50;
            --accent-orange: #f58220;
            --accent-pink: #e91e63;
            --accent-purple: #9c27b0;
            --accent-yellow: #ffeb3b;
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .console-wrapper {
            display: grid;
            grid-template-columns: 2fr 1fr 2fr 1.5fr; /* DeckA, Mixer, DeckB, Playlist */
            gap: 12px;
            width: 95vw;
            height: 95vh;
            background-color: #121417;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .deck, .mixer, .playlist-container {
            background-color: var(--deck-color);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        h2 {
            text-align: center; margin: 0 0 15px 0;
            font-size: 1.1em; font-weight: 600; color: var(--text-muted);
            border-bottom: 1px solid #3c424d; padding-bottom: 10px;
        }
        /* ... (rest of the styles are below) ... */
        .waveform-container { position: relative; background-color: #111; border-radius: 4px; height: 70px; margin-bottom: 10px; border: 1px solid #333; }
        .waveform-canvas, .waveform-progress { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .waveform-progress { background-color: rgba(0, 174, 255, 0.4); width: 0; }
        
        .jog-wheel { width: 150px; height: 150px; background: linear-gradient(145deg, #2b2f37, #1f232a); border-radius: 50%; margin: 10px auto; border: 5px solid #333; cursor: grab; display: flex; justify-content: center; align-items: center; box-shadow: inset 0 0 15px rgba(0,0,0,0.5); }
        .jog-wheel:active { cursor: grabbing; }
        .jog-wheel-inner { width: 70px; height: 70px; background: #1a1d22; border-radius: 50%; border: 1px solid #444; }

        .fader-group { display: flex; align-items: center; gap: 10px; font-size: 0.9em; }
        input[type="range"] { flex-grow: 1; -webkit-appearance: none; background: #111; height: 6px; border-radius: 3px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--text-light); border-radius: 50%; cursor: pointer; border: 2px solid #333; }
        input[type="range"].vertical-fader { writing-mode: vertical-lr; width: 10px; height: auto; flex-grow: 1; background: #111; }
        input[type="range"].vertical-fader::-webkit-slider-thumb { width: 24px; height: 24px; }
        input[type="number"] { width: 70px; background-color: #111; color: var(--text-light); border: 1px solid #444; border-radius: 4px; padding: 5px; text-align: center; }

        .button-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px; }
        .auto-loop-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 10px; }
        button { background-color: #3c424d; color: var(--text-light); border: 1px solid #555; padding: 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; font-weight: bold; transition: all 0.2s ease; }
        button:hover { border-color: var(--accent-blue); }
        button:disabled { background-color: #2a2e36; cursor: not-allowed; color: #666; border-color: #444;}
        
        .play-button.playing { background-color: var(--accent-green); box-shadow: 0 0 10px var(--accent-green); border-color: #fff; }
        .cue-button { background-color: var(--accent-orange); }
        .hot-cue-button { background-color: var(--accent-blue); }
        .loop-button.active { background-color: var(--accent-purple); box-shadow: 0 0 10px var(--accent-purple); border-color: #fff; }
        .sync-button.active { background-color: var(--accent-pink); box-shadow: 0 0 10px var(--accent-pink); border-color: #fff; }

        .mixer { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .knob-container { text-align: center; }
        .knob-label { font-size: 0.8em; color: var(--text-muted); }
        .filter-knob { width: 50px; height: 50px; transition: transform 0.1s linear; } /* JS will handle the rest */
        
        .playlist-container { background-color: var(--playlist-color); }
        #load-folder-btn { width: 100%; padding: 12px; font-size: 1em; background-color: var(--accent-blue); border: none; margin-bottom: 10px; }
        #playlist { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #playlist li { padding: 8px 12px; background-color: #3c424d; border-radius: 4px; margin-bottom: 5px; font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; }
        #playlist li:hover { background-color: #4c525d; }
        .load-track-btns button { font-size: 0.7em; padding: 4px 8px; margin-left: 5px; }

        #status { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.7); color: var(--text-light); padding: 5px 15px; border-radius: 20px; font-size: 0.9em; }
    </style>
</head>
<body>

<div class="console-wrapper">
    <div class="deck" id="deck-A">
        <h2>Deck A</h2>
        <div class="waveform-container"><canvas class="waveform-canvas"></canvas><div class="waveform-progress"></div></div>
        <div class="jog-wheel"><div class="jog-wheel-inner"></div></div>
        <div class="fader-group"><input type="range" class="bpm-slider" min="50" max="200" value="120" disabled><input type="number" class="bpm-input" min="50" max="200" value="120" disabled></div>
        <div class="button-grid">
            <button class="play-button" disabled>PLAY</button>
            <button class="cue-button" disabled>CUE</button>
            <button class="sync-button" disabled>SYNC</button>
        </div>
        <div class="button-grid">
            <button class="hot-cue-button" data-cue="0" disabled>CUE A</button>
            <button class="hot-cue-button" data-cue="1" disabled>CUE B</button>
            <button class="hot-cue-button" data-cue="2" disabled>CUE C</button>
        </div>
        <div class="auto-loop-grid">
            <button class="loop-button" data-beats="4" disabled>4</button>
            <button class="loop-button" data-beats="8" disabled>8</button>
            <button class="loop-button" data-beats="16" disabled>16</button>
            <button class="loop-button loop-toggle" disabled>EXIT</button>
        </div>
    </div>

    <div class="mixer">
        <div class="knob-container">
            <label class="knob-label">FILTER A</label>
            <canvas class="filter-knob" id="filter-A" width="50" height="50"></canvas>
        </div>
        <input type="range" class="vertical-fader volume-fader" id="volume-A" min="0" max="1" step="0.01" value="1" style="transform: rotate(180deg);">
        <input type="range" id="crossfader" min="-1" max="1" step="0.02" value="0">
        <input type="range" class="vertical-fader volume-fader" id="volume-B" min="0" max="1" step="0.01" value="1" style="transform: rotate(180deg);">
        <div class="knob-container">
            <label class="knob-label">FILTER B</label>
            <canvas class="filter-knob" id="filter-B" width="50" height="50"></canvas>
        </div>
    </div>

    <div class="deck" id="deck-B">
        <h2>Deck B</h2>
        <div class="waveform-container"><canvas class="waveform-canvas"></canvas><div class="waveform-progress"></div></div>
        <div class="jog-wheel"><div class="jog-wheel-inner"></div></div>
        <div class="fader-group"><input type="range" class="bpm-slider" min="50" max="200" value="120" disabled><input type="number" class="bpm-input" min="50" max="200" value="120" disabled></div>
        <div class="button-grid">
            <button class="play-button" disabled>PLAY</button>
            <button class="cue-button" disabled>CUE</button>
            <button class="sync-button" disabled>SYNC</button>
        </div>
        <div class="button-grid">
            <button class="hot-cue-button" data-cue="0" disabled>CUE A</button>
            <button class="hot-cue-button" data-cue="1" disabled>CUE B</button>
            <button class="hot-cue-button" data-cue="2" disabled>CUE C</button>
        </div>
        <div class="auto-loop-grid">
            <button class="loop-button" data-beats="4" disabled>4</button>
            <button class="loop-button" data-beats="8" disabled>8</button>
            <button class="loop-button" data-beats="16" disabled>16</button>
            <button class="loop-button loop-toggle" disabled>EXIT</button>
        </div>
    </div>
    
    <div class="playlist-container">
        <h2>PLAYLIST</h2>
        <button id="load-folder-btn">Load Folder</button>
        <ul id="playlist"></ul>
    </div>
</div>
<div id="status"></div>

<script>
    // --- GLOBAL STATE & SETUP ---
    const status = document.getElementById('status');
    let audioContext;
    let masterDeck = null;
    let animationFrameId = null;
    let playlistFiles = [];

    const decks = {
        A: { id: 'A', hotcues: [null, null, null], loop: {} },
        B: { id: 'B', hotcues: [null, null, null], loop: {} }
    };
    const mixer = {};

    // --- INITIALIZATION ---
    function initializeAudioContext() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        mixer.crossfadeA = audioContext.createGain();
        mixer.crossfadeB = audioContext.createGain();
        mixer.crossfadeA.connect(audioContext.destination);
        mixer.crossfadeB.connect(audioContext.destination);
        
        ['A', 'B'].forEach(id => {
            const d = decks[id];
            d.volumeNode = audioContext.createGain();
            d.filterNode = audioContext.createBiquadFilter();
            d.filterNode.connect(d.volumeNode);
            d.volumeNode.connect(id === 'A' ? mixer.crossfadeA : mixer.crossfadeB);
        });
        updateCrossfader({ target: { value: 0 } });
    }
    
    // --- EVENT LISTENERS ---
    document.addEventListener('DOMContentLoaded', () => {
        ['A', 'B'].forEach(id => {
            const deckEl = document.getElementById(`deck-${id}`);
            deckEl.querySelector('.play-button').addEventListener('click', () => togglePlayback(id));
            deckEl.querySelector('.cue-button').addEventListener('click', () => handleCue(id));
            deckEl.querySelector('.sync-button').addEventListener('click', () => handleSync(id));
            deckEl.querySelectorAll('.hot-cue-button').forEach(btn => btn.addEventListener('click', e => handleHotCue(id, parseInt(e.target.dataset.cue))));
            deckEl.querySelectorAll('.loop-button[data-beats]').forEach(btn => btn.addEventListener('click', e => handleAutoLoop(id, parseInt(e.target.dataset.beats))));
            deckEl.querySelector('.loop-toggle').addEventListener('click', () => toggleLoop(id, false));

            deckEl.querySelector('.bpm-slider').addEventListener('input', e => syncBpmInputs(e, id));
            deckEl.querySelector('.bpm-input').addEventListener('input', e => syncBpmInputs(e, id, false));

            setupJogWheel(deckEl.querySelector('.jog-wheel'), id);
            setupKnob(document.getElementById(`filter-${id}`), value => applyFilter(id, value));
        });

        document.getElementById('crossfader').addEventListener('input', updateCrossfader);
        document.getElementById('volume-A').addEventListener('input', e => decks.A.volumeNode.gain.value = e.target.value ** 2);
        document.getElementById('volume-B').addEventListener('input', e => decks.B.volumeNode.gain.value = e.target.value ** 2);
        document.getElementById('load-folder-btn').addEventListener('click', loadFolder);
    });

    // --- DECK & AUDIO FUNCTIONS ---
    async function loadTrack(deckId, file) {
        if (!file) return;
        initializeAudioContext();
        status.textContent = `Deck ${deckId}: Loading ${file.name}...`;
        resetDeck(deckId);
        
        const arrayBuffer = await file.arrayBuffer();
        decks[deckId].audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        drawWaveform(deckId);
        status.textContent = `Deck ${deckId}: Analyzing BPM...`;
        const bpm = await analyzeBpm(decks[deckId].audioBuffer);
        decks[deckId].originalBpm = bpm;
        updateBpmUI(deckId, bpm);
        
        enableControls(deckId, true);
        status.textContent = `Deck ${deckId}: Ready.`;
    }

    function togglePlayback(id) {
        decks[id].isPlaying ? stopSound(id) : playSound(id);
    }

    function playSound(id) {
        const d = decks[id];
        if (!d.audioBuffer) return;
        
        d.sourceNode = audioContext.createBufferSource();
        d.sourceNode.buffer = d.audioBuffer;
        d.sourceNode.connect(d.filterNode);
        
        updatePlaybackRate(id);
        
        if (d.loop.active && d.loop.start != null && d.loop.end != null) {
            d.sourceNode.loop = true;
            d.sourceNode.loopStart = d.loop.start;
            d.sourceNode.loopEnd = d.loop.end;
        }
        
        const startTime = d.cuePoint || 0;
        d.sourceNode.start(0, startTime);
        d.startTime = audioContext.currentTime - startTime;
        d.isPlaying = true;
        
        const btn = document.querySelector(`#deck-${id} .play-button`);
        btn.textContent = 'PAUSE';
        btn.classList.add('playing');
        
        if (!animationFrameId) startVisualUpdates();
    }

    function stopSound(id) {
        const d = decks[id];
        if (!d.sourceNode) return;
        d.cuePoint = audioContext.currentTime - d.startTime;
        d.sourceNode.stop();
        d.sourceNode.disconnect();
        d.sourceNode = null;
        d.isPlaying = false;
        
        const btn = document.querySelector(`#deck-${id} .play-button`);
        btn.textContent = 'PLAY';
        btn.classList.remove('playing');
        
        if (!decks.A.isPlaying && !decks.B.isPlaying) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    }
    
    function updatePlaybackRate(id) {
        const d = decks[id];
        if (!d.sourceNode || !d.originalBpm) return;
        const newBpm = parseFloat(document.querySelector(`#deck-${id} .bpm-input`).value);
        const rate = newBpm / d.originalBpm;
        d.sourceNode.playbackRate.value = rate;
    }

    // --- FEATURE FUNCTIONS (SYNC, CUE, LOOP) ---
    function handleSync(id) {
        const d = decks[id];
        const otherId = id === 'A' ? 'B' : 'A';
        const btn = document.querySelector(`#deck-${id} .sync-button`);
        
        if (d.syncActive) {
            d.syncActive = false;
            btn.classList.remove('active');
            if (masterDeck === id) { // If it was master, find new master or none
                masterDeck = decks[otherId].syncActive ? otherId : null;
            }
        } else {
            d.syncActive = true;
            btn.classList.add('active');
            if (!masterDeck) masterDeck = id;
            
            const masterBpm = parseFloat(document.querySelector(`#deck-${masterDeck} .bpm-input`).value);
            updateBpmUI(id, masterBpm);
            if(d.isPlaying) updatePlaybackRate(id);
        }
    }

    function handleCue(id) {
        const d = decks[id];
        if (d.isPlaying) {
            stopSound(id);
            d.cuePoint = d.mainCuePoint || 0;
            updateProgress(id);
        } else {
            d.mainCuePoint = d.cuePoint || 0;
            status.textContent = `Deck ${id}: Main CUE set.`;
        }
    }
    
    function handleHotCue(id, cueIndex) {
        const d = decks[id];
        const currentTime = d.isPlaying ? audioContext.currentTime - d.startTime : (d.cuePoint || 0);
        
        if (d.hotcues[cueIndex] !== null) {
            d.cuePoint = d.hotcues[cueIndex];
            if (d.isPlaying) stopSound(id);
            playSound(id);
        } else {
            d.hotcues[cueIndex] = currentTime;
            document.querySelector(`#deck-${id} .hot-cue-button[data-cue='${cueIndex}']`).style.backgroundColor = var(--accent-yellow);
        }
    }

    function handleAutoLoop(id, beats) {
        const d = decks[id];
        if (!d.originalBpm) return;
        const currentTime = d.isPlaying ? audioContext.currentTime - d.startTime : (d.cuePoint || 0);
        const beatDuration = 60 / parseFloat(document.querySelector(`#deck-${id} .bpm-input`).value);
        const loopDuration = beats * beatDuration;
        
        d.loop.start = currentTime;
        d.loop.end = currentTime + loopDuration;
        toggleLoop(id, true);
    }
    
    function toggleLoop(id, activate) {
        const d = decks[id];
        d.loop.active = activate;
        document.querySelector(`#deck-${id} .loop-toggle`).classList.toggle('active', activate);
        if (d.isPlaying) {
            stopSound(id);
            playSound(id);
        }
    }

    // --- MIXER FUNCTIONS ---
    function updateCrossfader(event) {
        const val = parseFloat(event.target.value); // Range -1 to 1
        const gainA = Math.cos((val + 1) / 2 * 0.5 * Math.PI);
        const gainB = Math.cos((1 - val) / 2 * 0.5 * Math.PI);
        mixer.crossfadeA.gain.setTargetAtTime(gainA, audioContext.currentTime, 0.01);
        mixer.crossfadeB.gain.setTargetAtTime(gainB, audioContext.currentTime, 0.01);
    }
    
    function applyFilter(id, value) { // value 0 to 1
        const filterNode = decks[id].filterNode;
        const maxFreq = audioContext.sampleRate / 2;
        
        if (value === 0.5) { // Center off
            filterNode.frequency.setTargetAtTime(maxFreq, audioContext.currentTime, 0.01);
        } else if (value < 0.5) { // Low-pass
            filterNode.type = 'lowpass';
            const freq = Math.pow(10, 2 + (value * 2) * 2.5);
            filterNode.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.01);
        } else { // High-pass
            filterNode.type = 'highpass';
            const freq = Math.pow(10, 1 + ((value - 0.5) * 2) * 3);
            filterNode.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.01);
        }
    }

    // --- PLAYLIST FUNCTIONS ---
    async function loadFolder() {
        if (!('showDirectoryPicker' in window)) {
            alert('Your browser does not support the Folder Selection API.');
            return;
        }
        try {
            const directoryHandle = await window.showDirectoryPicker();
            playlistFiles = [];
            for await (const entry of directoryHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(mp3|wav|ogg|flac|m4a)$/i)) {
                    playlistFiles.push(entry);
                }
            }
            renderPlaylist();
        } catch (err) {
            console.error('Folder selection cancelled or failed:', err);
        }
    }

    function renderPlaylist() {
        const playlistEl = document.getElementById('playlist');
        playlistEl.innerHTML = '';
        playlistFiles.forEach((fileHandle, index) => {
            const li = document.createElement('li');
            li.textContent = fileHandle.name.replace(/\.[^/.]+$/, "");
            
            const btnContainer = document.createElement('div');
            btnContainer.className = 'load-track-btns';
            
            const btnA = document.createElement('button');
            btnA.textContent = 'A';
            btnA.onclick = async () => loadTrack('A', await fileHandle.getFile());
            
            const btnB = document.createElement('button');
            btnB.textContent = 'B';
            btnB.onclick = async () => loadTrack('B', await fileHandle.getFile());
            
            btnContainer.appendChild(btnA);
            btnContainer.appendChild(btnB);
            li.appendChild(btnContainer);
            playlistEl.appendChild(li);
        });
    }

    // --- UI & VISUALS ---
    function startVisualUpdates() {
        function updateLoop() {
            ['A', 'B'].forEach(id => {
                if (decks[id].isPlaying) updateProgress(id);
            });
            animationFrameId = requestAnimationFrame(updateLoop);
        }
        updateLoop();
    }
    
    function updateProgress(id) {
        const d = decks[id];
        if (!d.audioBuffer) return;
        const elapsed = d.isPlaying ? audioContext.currentTime - d.startTime : d.cuePoint;
        const progress = (elapsed / d.audioBuffer.duration) * 100;
        document.querySelector(`#deck-${id} .waveform-progress`).style.width = `${Math.min(100, progress)}%`;
    }

    // ... (All other UI, BPM, and utility functions remain below)
    function setupJogWheel(jogEl, id){/* ... Jog wheel logic ... */}
    function setupKnob(canvas, callback){
        let value = 0.5;
        const ctx = canvas.getContext('2d');
        const draw = () => {
            const angle = (value * 1.5 - 0.75) * Math.PI;
            ctx.clearRect(0, 0, 50, 50);
            ctx.fillStyle = '#2a2e36';
            ctx.beginPath(); ctx.arc(25, 25, 24, 0, 2 * Math.PI); ctx.fill();
            ctx.strokeStyle = '#4c525d'; ctx.lineWidth = 2; ctx.stroke();
            ctx.strokeStyle = var(--accent-blue); ctx.lineWidth = 3; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(25, 25); ctx.lineTo(25 + Math.sin(angle) * 20, 25 - Math.cos(angle) * 20); ctx.stroke();
        };
        const handleInteraction = (e) => {
            e.preventDefault();
            const startY = e.clientY || e.touches[0].clientY;
            const startValue = value;
            const onMove = (moveEvent) => {
                const currentY = moveEvent.clientY || moveEvent.touches[0].clientY;
                const deltaY = startY - currentY;
                value = Math.max(0, Math.min(1, startValue + deltaY / 200));
                draw();
                callback(value);
            };
            const onEnd = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onEnd);
                document.removeEventListener('touchmove', onMove);
                document.removeEventListener('touchend', onEnd);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);
            document.addEventListener('touchmove', onMove);
            document.addEventListener('touchend', onEnd);
        };
        canvas.addEventListener('mousedown', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction);
        draw();
    }
    function drawWaveform(id){/* ... Waveform drawing ... */}
    function syncBpmInputs(event, id, updateSlider = true){
        const newBpm = parseFloat(event.target.value);
        const deckEl = document.getElementById(`deck-${id}`);
        if(updateSlider) deckEl.querySelector('.bpm-slider').value = newBpm;
        deckEl.querySelector('.bpm-input').value = newBpm;
        if(decks[id].isPlaying) updatePlaybackRate(id);
    }
    function updateBpmUI(id, bpm){/* ... BPM UI update ... */}
    function enableControls(id, isEnabled){/* ... Enable/disable controls ... */}
    function resetDeck(id){/* ... Reset deck state ... */}
    async function analyzeBpm(audioBuffer) {/* ... BPM analysis logic ... */ return 128.0; } // Placeholder
</script>
</body>
</html>
