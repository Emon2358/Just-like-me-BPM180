<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automatic MP3 BPM Adjuster</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 500px;
            text-align: center;
        }
        h1 {
            color: #1a73e8;
            margin-bottom: 25px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: left;
        }
        input[type="file"] {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 6px;
            border: 1px solid #ddd;
            cursor: pointer;
            background-color: #f9f9f9;
        }
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
        }
        button:hover {
            background-color: #155ab6;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .bpm-info {
            background-color: #e8f0fe;
            border-left: 5px solid #1a73e8;
            padding: 15px;
            margin-bottom: 20px;
            text-align: left;
            border-radius: 5px;
        }
        .bpm-info p {
            margin: 0;
            font-size: 1.1em;
        }
        .bpm-info strong {
            font-size: 1.4em;
            color: #1a73e8;
        }
        .bpm-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .bpm-controls input[type="range"] {
            flex-grow: 1;
        }
        .bpm-controls input[type="number"] {
            width: 80px;
        }
        #status {
            margin-top: 20px;
            color: #555;
            min-height: 20px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Automatic BPM Adjuster 🎶</h1>

    <div class="control-group">
        <label for="file-input">1. MP3ファイルを選択</label>
        <input type="file" id="file-input" accept=".mp3">
    </div>

    <div id="bpm-info-container" class="bpm-info" style="display: none;">
        <p>解析されたBPM: <strong id="detected-bpm-display">...</strong></p>
    </div>

    <div class="control-group">
        <label for="bpm-slider">2. BPMを調整</label>
        <div class="bpm-controls">
            <input type="range" id="bpm-slider" min="50" max="200" value="120" disabled>
            <input type="number" id="bpm-input" min="50" max="200" value="120" disabled>
        </div>
    </div>

    <div class="control-group">
        <button id="play-pause-button" disabled>再生</button>
        <button id="download-button" disabled>WAV形式でダウンロード</button>
    </div>

    <p id="status"></p>
</div>

<script>
    // --- DOM要素の取得 ---
    const fileInput = document.getElementById('file-input');
    const bpmSlider = document.getElementById('bpm-slider');
    const bpmInput = document.getElementById('bpm-input');
    const detectedBpmDisplay = document.getElementById('detected-bpm-display');
    const bpmInfoContainer = document.getElementById('bpm-info-container');
    const playPauseButton = document.getElementById('play-pause-button');
    const downloadButton = document.getElementById('download-button');
    const status = document.getElementById('status');

    // --- Web Audio APIの初期化 ---
    let audioContext;
    let audioBuffer;
    let sourceNode;
    let isPlaying = false;
    let originalBpm = 0;

    // --- イベントリスナー ---
    fileInput.addEventListener('change', handleFileSelect);
    bpmSlider.addEventListener('input', syncBpmInputs);
    bpmInput.addEventListener('input', syncBpmInputs);
    playPauseButton.addEventListener('click', togglePlayback);
    downloadButton.addEventListener('click', downloadAdjustedAudio);

    // --- 機能の有効/無効化 ---
    function updateControlsState(isReady) {
        bpmSlider.disabled = !isReady;
        bpmInput.disabled = !isReady;
        playPauseButton.disabled = !isReady;
        downloadButton.disabled = !isReady;
    }

    // --- ファイル選択時の処理 ---
    async function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        updateControlsState(false);
        bpmInfoContainer.style.display = 'none';
        status.textContent = 'ファイルをデコード中...';

        try {
            const arrayBuffer = await file.arrayBuffer();
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            status.textContent = 'BPMを解析中... (曲の長さにより時間がかかります)';
            // BPM解析処理を少し遅延させてUIの更新を確実に行う
            setTimeout(async () => {
                const detectedBpm = await analyzeBpm(audioBuffer);
                originalBpm = detectedBpm;

                detectedBpmDisplay.textContent = Math.round(originalBpm * 10) / 10;
                bpmInfoContainer.style.display = 'block';

                // スライダー等の範囲と現在値を更新
                const baseBpm = Math.round(originalBpm);
                bpmSlider.min = Math.floor(baseBpm * 0.5);
                bpmSlider.max = Math.ceil(baseBpm * 2);
                bpmInput.min = Math.floor(baseBpm * 0.5);
                bpmInput.max = Math.ceil(baseBpm * 2);
                bpmSlider.value = baseBpm;
                bpmInput.value = baseBpm;
                
                status.textContent = '準備ができました。';
                updateControlsState(true);
            }, 100);

        } catch (error) {
            status.textContent = 'エラー: ファイルの処理に失敗しました。';
            console.error(error);
            audioBuffer = null;
        }
    }

    // --- BPMスライダーと入力欄の同期・再生レート更新 ---
    function syncBpmInputs(event) {
        const newBpm = event.target.value;
        bpmSlider.value = newBpm;
        bpmInput.value = newBpm;
        updatePlaybackRate();
    }
    
    function updatePlaybackRate() {
        if (isPlaying && sourceNode && originalBpm > 0) {
            const newBpm = parseFloat(bpmInput.value);
            sourceNode.playbackRate.value = newBpm / originalBpm;
        }
    }

    // --- 再生/停止 ---
    function togglePlayback() {
        if (isPlaying) {
            stopSound();
        } else {
            playSound();
        }
    }

    function playSound() {
        if (!audioBuffer || !audioContext) return;
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.connect(audioContext.destination);
        sourceNode.onended = () => {
            if (isPlaying) stopSound();
        };
        updatePlaybackRate(); // 再生開始前にレートを設定
        sourceNode.start(0);
        isPlaying = true;
        playPauseButton.textContent = '停止';
    }

    function stopSound() {
        if (sourceNode) {
            sourceNode.stop();
            sourceNode.disconnect();
            sourceNode = null;
        }
        isPlaying = false;
        playPauseButton.textContent = '再生';
    }

    // --- BPM解析 ---
    async function analyzeBpm(audioBuffer) {
        // オフラインコンテキストで音声データを高速処理
        const offlineCtx = new OfflineAudioContext(1, audioBuffer.length, audioBuffer.sampleRate);
        const source = offlineCtx.createBufferSource();
        source.buffer = audioBuffer;

        // ビートが豊富な低周波帯を抽出するフィルター
        const filter = offlineCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 150; // Hz
        filter.Q.value = 1;

        source.connect(filter);
        filter.connect(offlineCtx.destination);
        source.start(0);

        const processedBuffer = await offlineCtx.startRendering();
        const data = processedBuffer.getChannelData(0);
        
        // エネルギーのピーク（ビート）を検出
        const peaks = getPeaks(data, audioBuffer.sampleRate);
        if (peaks.length < 2) return 120; // デフォルト値

        // ピーク間の間隔を分析
        const intervals = getIntervals(peaks);
        
        // 最も可能性の高いBPMを特定
        const topBpm = getTopBpm(intervals, audioBuffer.sampleRate);

        return topBpm.bpm;
    }

    function getPeaks(data, sampleRate) {
        const peaks = [];
        const threshold = 0.6; // ピーク検出の閾値
        for (let i = 1; i < data.length - 1; i++) {
            if (data[i] > data[i - 1] && data[i] > data[i + 1] && data[i] > threshold) {
                peaks.push(i);
            }
        }
        return peaks;
    }

    function getIntervals(peaks) {
        const intervals = [];
        for (let i = 0; i < peaks.length - 1; i++) {
            intervals.push(peaks[i + 1] - peaks[i]);
        }
        return intervals;
    }

    function getTopBpm(intervals, sampleRate) {
        const intervalCounts = {};
        intervals.forEach(interval => {
            // BPMの候補を計算 (60秒 / (サンプル間隔 / サンプルレート))
            const theoreticalBpm = 60 / (interval / sampleRate);
            
            // BPMを妥当な範囲(70-180)に丸め込む
            let roundedBpm = Math.round(theoreticalBpm);
            while(roundedBpm < 70) roundedBpm *= 2;
            while(roundedBpm > 180) roundedBpm /= 2;
            roundedBpm = Math.round(roundedBpm);

            intervalCounts[roundedBpm] = (intervalCounts[roundedBpm] || 0) + 1;
        });

        // 最も頻出するBPMグループを見つける
        let topBpm = { bpm: 120, count: 0 };
        for (const bpm in intervalCounts) {
            if (intervalCounts[bpm] > topBpm.count) {
                topBpm = { bpm: parseFloat(bpm), count: intervalCounts[bpm] };
            }
        }
        return topBpm;
    }
    
    // --- ダウンロード処理 (変更なし) ---
    async function downloadAdjustedAudio() {
        if (!audioBuffer || !originalBpm) {
            alert('オーディオファイルが設定されていません。');
            return;
        }
        
        status.textContent = '音源をレンダリング中...これには数秒かかります。';
        downloadButton.disabled = true;

        try {
            const newBpm = parseFloat(bpmInput.value);
            const playbackRate = newBpm / originalBpm;
            
            const offlineContext = new OfflineAudioContext(
                audioBuffer.numberOfChannels,
                Math.ceil(audioBuffer.length / playbackRate), // 再生速度に合わせて長さを調整
                audioBuffer.sampleRate
            );

            const offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = audioBuffer;
            offlineSource.playbackRate.value = playbackRate;
            offlineSource.connect(offlineContext.destination);
            offlineSource.start(0);

            const renderedBuffer = await offlineContext.startRendering();
            const wavBlob = bufferToWav(renderedBuffer);

            const url = URL.createObjectURL(wavBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `adjusted_bpm_${newBpm}.wav`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            status.textContent = 'ダウンロードが完了しました。';
        } catch(e) {
            status.textContent = 'エラー: 音源の生成に失敗しました。';
            console.error(e);
        } finally {
            downloadButton.disabled = false;
        }
    }

    function bufferToWav(buffer) {
        const numOfChan = buffer.numberOfChannels;
        const length = buffer.length * numOfChan * 2 + 44;
        const bufferArr = new ArrayBuffer(length);
        const view = new DataView(bufferArr);
        const channels = [];
        let i, sample;
        let offset = 0, pos = 0;
        
        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8);
        setUint32(0x45564157); // "WAVE"
        setUint32(0x20746d66); // "fmt "
        setUint32(16);
        setUint16(1);
        setUint16(numOfChan);
        setUint32(buffer.sampleRate);
        setUint32(buffer.sampleRate * 2 * numOfChan);
        setUint16(numOfChan * 2);
        setUint16(16);
        setUint32(0x61746164); // "data"
        setUint32(length - pos - 4);

        for (i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));

        while (pos < length) {
            for (i = 0; i < numOfChan; i++) {
                sample = Math.max(-1, Math.min(1, channels[i][offset]));
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
            offset++;
        }
        return new Blob([view], { type: 'audio/wav' });
    }

</script>
</body>
</html>
