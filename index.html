<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Web DJ Console</title>
    <style>
        :root {
            --bg-color: #1a1d22;
            --deck-color: #24282f;
            --playlist-color: #2a2e36;
            --text-light: #e6e6e6;
            --text-muted: #8c92a4;
            --accent-blue: #00aeff;
            --accent-green: #4caf50;
            --accent-orange: #f58220;
            --accent-pink: #e91e63;
            --accent-purple: #9c27b0;
            --accent-yellow: #ffeb3b;
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .console-wrapper {
            display: grid;
            grid-template-columns: 2fr 1fr 2fr 1.5fr; /* DeckA, Mixer, DeckB, Playlist */
            gap: 12px;
            width: 95vw;
            height: 95vh;
            background-color: #121417;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .deck, .mixer, .playlist-container {
            background-color: var(--deck-color);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        h2 {
            text-align: center; margin: 0 0 15px 0;
            font-size: 1.1em; font-weight: 600; color: var(--text-muted);
            border-bottom: 1px solid #3c424d; padding-bottom: 10px;
        }
        .waveform-container { position: relative; background-color: #111; border-radius: 4px; height: 70px; margin-bottom: 10px; border: 1px solid #333; }
        .waveform-canvas, .waveform-progress { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .waveform-progress { background-color: rgba(0, 174, 255, 0.4); width: 0; }
        .jog-wheel { width: 150px; height: 150px; background: linear-gradient(145deg, #2b2f37, #1f232a); border-radius: 50%; margin: 10px auto; border: 5px solid #333; cursor: grab; display: flex; justify-content: center; align-items: center; box-shadow: inset 0 0 15px rgba(0,0,0,0.5); }
        .jog-wheel:active { cursor: grabbing; }
        .jog-wheel-inner { width: 70px; height: 70px; background: #1a1d22; border-radius: 50%; border: 1px solid #444; }
        .fader-group { display: flex; align-items: center; gap: 10px; font-size: 0.9em; }
        input[type="range"] { flex-grow: 1; -webkit-appearance: none; background: #111; height: 6px; border-radius: 3px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--text-light); border-radius: 50%; cursor: pointer; border: 2px solid #333; }
        input[type="range"].vertical-fader { writing-mode: vertical-lr; width: 10px; height: auto; flex-grow: 1; background: #111; }
        input[type="range"].vertical-fader::-webkit-slider-thumb { width: 24px; height: 24px; }
        input[type="number"] { width: 70px; background-color: #111; color: var(--text-light); border: 1px solid #444; border-radius: 4px; padding: 5px; text-align: center; }
        .button-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px; }
        .auto-loop-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 10px; }
        button { background-color: #3c424d; color: var(--text-light); border: 1px solid #555; padding: 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; font-weight: bold; transition: all 0.2s ease; }
        button:hover { border-color: var(--accent-blue); }
        button:disabled { background-color: #2a2e36; cursor: not-allowed; color: #666; border-color: #444;}
        .play-button.playing { background-color: var(--accent-green); box-shadow: 0 0 10px var(--accent-green); border-color: #fff; }
        .cue-button { background-color: var(--accent-orange); }
        .hot-cue-button { background-color: var(--accent-blue); }
        .loop-button.active { background-color: var(--accent-purple); box-shadow: 0 0 10px var(--accent-purple); border-color: #fff; }
        .sync-button.active { background-color: var(--accent-pink); box-shadow: 0 0 10px var(--accent-pink); border-color: #fff; }
        .mixer { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .knob-container { text-align: center; }
        .knob-label { font-size: 0.8em; color: var(--text-muted); }
        .filter-knob { width: 50px; height: 50px; transition: transform 0.1s linear; }
        .playlist-container { background-color: var(--playlist-color); }
        #load-folder-btn { width: 100%; padding: 12px; font-size: 1em; background-color: var(--accent-blue); border: none; margin-bottom: 10px; }
        #playlist { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #playlist li { padding: 8px 12px; background-color: #3c424d; border-radius: 4px; margin-bottom: 5px; font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; }
        #playlist li:hover { background-color: #4c525d; }
        .load-track-btns button { font-size: 0.7em; padding: 4px 8px; margin-left: 5px; }
        #status { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.7); color: var(--text-light); padding: 5px 15px; border-radius: 20px; font-size: 0.9em; }
    </style>
</head>
<body>

<div class="console-wrapper">
    <div class="deck" id="deck-A">
        <h2>Deck A</h2>
        <div class="waveform-container"><canvas class="waveform-canvas"></canvas><div class="waveform-progress"></div></div>
        <div class="jog-wheel"><div class="jog-wheel-inner"></div></div>
        <div class="fader-group"><input type="range" class="bpm-slider" min="50" max="200" value="120" disabled><input type="number" class="bpm-input" min="50" max="200" value="120" disabled></div>
        <div class="button-grid">
            <button class="play-button" disabled>PLAY</button>
            <button class="cue-button" disabled>CUE</button>
            <button class="sync-button" disabled>SYNC</button>
        </div>
        <div class="button-grid">
            <button class="hot-cue-button" data-cue="0" disabled>CUE A</button>
            <button class="hot-cue-button" data-cue="1" disabled>CUE B</button>
            <button class="hot-cue-button" data-cue="2" disabled>CUE C</button>
        </div>
        <div class="auto-loop-grid">
            <button class="loop-button" data-beats="4" disabled>4</button>
            <button class="loop-button" data-beats="8" disabled>8</button>
            <button class="loop-button" data-beats="16" disabled>16</button>
            <button class="loop-button loop-toggle" disabled>EXIT</button>
        </div>
    </div>

    <div class="mixer">
        <div class="knob-container">
            <label class="knob-label">FILTER A</label>
            <canvas class="filter-knob" id="filter-A" width="50" height="50"></canvas>
        </div>
        <input type="range" class="vertical-fader volume-fader" id="volume-A" min="0" max="1" step="0.01" value="1" style="transform: rotate(180deg);">
        <input type="range" id="crossfader" min="-1" max="1" step="0.02" value="0">
        <input type="range" class="vertical-fader volume-fader" id="volume-B" min="0" max="1" step="0.01" value="1" style="transform: rotate(180deg);">
        <div class="knob-container">
            <label class="knob-label">FILTER B</label>
            <canvas class="filter-knob" id="filter-B" width="50" height="50"></canvas>
        </div>
    </div>

    <div class="deck" id="deck-B">
        <h2>Deck B</h2>
        <div class="waveform-container"><canvas class="waveform-canvas"></canvas><div class="waveform-progress"></div></div>
        <div class="jog-wheel"><div class="jog-wheel-inner"></div></div>
        <div class="fader-group"><input type="range" class="bpm-slider" min="50" max="200" value="120" disabled><input type="number" class="bpm-input" min="50" max="200" value="120" disabled></div>
        <div class="button-grid">
            <button class="play-button" disabled>PLAY</button>
            <button class="cue-button" disabled>CUE</button>
            <button class="sync-button" disabled>SYNC</button>
        </div>
        <div class="button-grid">
            <button class="hot-cue-button" data-cue="0" disabled>CUE A</button>
            <button class="hot-cue-button" data-cue="1" disabled>CUE B</button>
            <button class="hot-cue-button" data-cue="2" disabled>CUE C</button>
        </div>
        <div class="auto-loop-grid">
            <button class="loop-button" data-beats="4" disabled>4</button>
            <button class="loop-button" data-beats="8" disabled>8</button>
            <button class="loop-button" data-beats="16" disabled>16</button>
            <button class="loop-button loop-toggle" disabled>EXIT</button>
        </div>
    </div>
    
    <div class="playlist-container">
        <h2>PLAYLIST</h2>
        <button id="load-folder-btn">Load Folder</button>
        <ul id="playlist"></ul>
    </div>
</div>
<div id="status"></div>

<script>
    // --- GLOBAL STATE & SETUP ---
    const status = document.getElementById('status');
    let audioContext;
    let masterDeck = null;
    let animationFrameId = null;
    let playlistFiles = [];

    const decks = {
        A: { id: 'A', hotcues: [null, null, null], loop: {} },
        B: { id: 'B', hotcues: [null, null, null], loop: {} }
    };
    const mixer = {};

    // --- INITIALIZATION ---
    function initializeAudioContext() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        mixer.crossfadeA = audioContext.createGain();
        mixer.crossfadeB = audioContext.createGain();
        mixer.crossfadeA.connect(audioContext.destination);
        mixer.crossfadeB.connect(audioContext.destination);
        
        ['A', 'B'].forEach(id => {
            const d = decks[id];
            d.volumeNode = audioContext.createGain();
            d.filterNode = audioContext.createBiquadFilter();
            d.filterNode.connect(d.volumeNode);
            d.volumeNode.connect(id === 'A' ? mixer.crossfadeA : mixer.crossfadeB);
        });
        updateCrossfader({ target: { value: 0 } });
    }
    
    // --- EVENT LISTENERS ---
    document.addEventListener('DOMContentLoaded', () => {
        ['A', 'B'].forEach(id => {
            const deckEl = document.getElementById(`deck-${id}`);
            deckEl.querySelector('.play-button').addEventListener('click', () => togglePlayback(id));
            deckEl.querySelector('.cue-button').addEventListener('click', () => handleCue(id));
            deckEl.querySelector('.sync-button').addEventListener('click', () => handleSync(id));
            deckEl.querySelectorAll('.hot-cue-button').forEach(btn => btn.addEventListener('click', e => handleHotCue(id, parseInt(e.target.dataset.cue))));
            deckEl.querySelectorAll('.loop-button[data-beats]').forEach(btn => btn.addEventListener('click', e => handleAutoLoop(id, parseInt(e.target.dataset.beats))));
            deckEl.querySelector('.loop-toggle').addEventListener('click', () => toggleLoop(id, false));
            deckEl.querySelector('.bpm-slider').addEventListener('input', e => syncBpmInputs(e, id));
            deckEl.querySelector('.bpm-input').addEventListener('input', e => syncBpmInputs(e, id, false));
            setupJogWheel(deckEl.querySelector('.jog-wheel'), id);
            setupKnob(document.getElementById(`filter-${id}`), value => applyFilter(id, value));
        });

        document.getElementById('crossfader').addEventListener('input', updateCrossfader);
        
        // ▼▼▼ ERROR FIX ▼▼▼
        document.getElementById('volume-A').addEventListener('input', e => {
            if (decks.A.volumeNode) decks.A.volumeNode.gain.value = e.target.value ** 2;
        });
        document.getElementById('volume-B').addEventListener('input', e => {
            if (decks.B.volumeNode) decks.B.volumeNode.gain.value = e.target.value ** 2;
        });
        // ▲▲▲ ERROR FIX ▲▲▲

        document.getElementById('load-folder-btn').addEventListener('click', loadFolder);
    });

    // --- DECK & AUDIO FUNCTIONS ---
    async function loadTrack(deckId, file) {
        if (!file) return;
        initializeAudioContext();
        status.textContent = `Deck ${deckId}: Loading ${file.name}...`;
        resetDeck(deckId);
        
        const arrayBuffer = await file.arrayBuffer();
        decks[deckId].audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        drawWaveform(deckId);
        status.textContent = `Deck ${deckId}: Analyzing BPM...`;
        const bpm = await analyzeBpm(decks[deckId].audioBuffer);
        decks[deckId].originalBpm = bpm;
        updateBpmUI(deckId, bpm);
        
        enableControls(deckId, true);
        status.textContent = `Deck ${deckId}: Ready.`;
    }

    function togglePlayback(id) {
        decks[id].isPlaying ? stopSound(id) : playSound(id);
    }

    function playSound(id) {
        const d = decks[id];
        if (!d.audioBuffer) return;
        
        d.sourceNode = audioContext.createBufferSource();
        d.sourceNode.buffer = d.audioBuffer;
        d.sourceNode.connect(d.filterNode);
        
        updatePlaybackRate(id);
        
        if (d.loop.active && d.loop.start != null && d.loop.end != null) {
            d.sourceNode.loop = true;
            d.sourceNode.loopStart = d.loop.start;
            d.sourceNode.loopEnd = d.loop.end;
        }
        
        const startTime = d.cuePoint || 0;
        d.sourceNode.start(0, startTime);
        d.startTime = audioContext.currentTime - startTime;
        d.isPlaying = true;
        
        const btn = document.querySelector(`#deck-${id} .play-button`);
        btn.textContent = 'PAUSE';
        btn.classList.add('playing');
        
        if (!animationFrameId) startVisualUpdates();
    }

    function stopSound(id) {
        const d = decks[id];
        if (!d.sourceNode) return;
        d.cuePoint = audioContext.currentTime - d.startTime;
        d.sourceNode.stop();
        d.sourceNode.disconnect();
        d.sourceNode = null;
        d.isPlaying = false;
        
        const btn = document.querySelector(`#deck-${id} .play-button`);
        btn.textContent = 'PLAY';
        btn.classList.remove('playing');
        
        if (!decks.A.isPlaying && !decks.B.isPlaying) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    }
    
    function updatePlaybackRate(id) {
        const d = decks[id];
        if (!d.sourceNode || !d.originalBpm) return;
        const newBpm = parseFloat(document.querySelector(`#deck-${id} .bpm-input`).value);
        const rate = newBpm / d.originalBpm;
        d.sourceNode.playbackRate.value = rate;
    }

    // --- FEATURE FUNCTIONS (SYNC, CUE, LOOP) ---
    function handleSync(id) {
        const d = decks[id];
        const otherId = id === 'A' ? 'B' : 'A';
        const btn = document.querySelector(`#deck-${id} .sync-button`);
        
        if (d.syncActive) {
            d.syncActive = false;
            btn.classList.remove('active');
            if (masterDeck === id) { 
                masterDeck = decks[otherId].syncActive ? otherId : null;
            }
        } else {
            d.syncActive = true;
            btn.classList.add('active');
            if (!masterDeck) masterDeck = id;
            
            const masterBpm = parseFloat(document.querySelector(`#deck-${masterDeck} .bpm-input`).value);
            updateBpmUI(id, masterBpm);
            if(d.isPlaying) updatePlaybackRate(id);
        }
    }

    function handleCue(id) {
        const d = decks[id];
        if (d.isPlaying) {
            stopSound(id);
            d.cuePoint = d.mainCuePoint || 0;
            updateProgress(id);
        } else {
            d.mainCuePoint = d.cuePoint || 0;
            status.textContent = `Deck ${id}: Main CUE set.`;
        }
    }
    
    function handleHotCue(id, cueIndex) {
        const d = decks[id];
        const currentTime = d.isPlaying ? audioContext.currentTime - d.startTime : (d.cuePoint || 0);
        
        if (d.hotcues[cueIndex] !== null) {
            d.cuePoint = d.hotcues[cueIndex];
            if (d.isPlaying) stopSound(id);
            playSound(id);
        } else {
            d.hotcues[cueIndex] = currentTime;
            document.querySelector(`#deck-${id} .hot-cue-button[data-cue='${cueIndex}']`).style.backgroundColor = '#ffeb3b';
        }
    }

    function handleAutoLoop(id, beats) {
        const d = decks[id];
        if (!d.originalBpm) return;
        const currentTime = d.isPlaying ? audioContext.currentTime - d.startTime : (d.cuePoint || 0);
        const beatDuration = 60 / parseFloat(document.querySelector(`#deck-${id} .bpm-input`).value);
        const loopDuration = beats * beatDuration;
        
        d.loop.start = currentTime;
        d.loop.end = currentTime + loopDuration;
        toggleLoop(id, true);
    }
    
    function toggleLoop(id, activate) {
        const d = decks[id];
        d.loop.active = activate;
        document.querySelector(`#deck-${id} .loop-toggle`).classList.toggle('active', activate);
        if (d.isPlaying) {
            stopSound(id);
            playSound(id);
        }
    }

    // --- MIXER FUNCTIONS ---
    function updateCrossfader(event) {
        const val = parseFloat(event.target.value); // Range -1 to 1
        const gainA = Math.cos((val + 1) / 2 * 0.5 * Math.PI);
        const gainB = Math.cos((1 - val) / 2 * 0.5 * Math.PI);
        if(mixer.crossfadeA) mixer.crossfadeA.gain.setTargetAtTime(gainA, audioContext.currentTime, 0.01);
        if(mixer.crossfadeB) mixer.crossfadeB.gain.setTargetAtTime(gainB, audioContext.currentTime, 0.01);
    }
    
    function applyFilter(id, value) { // value 0 to 1
        const filterNode = decks[id].filterNode;
        if (!audioContext) return;
        const maxFreq = audioContext.sampleRate / 2;
        
        if (value > 0.49 && value < 0.51) { 
            filterNode.frequency.setTargetAtTime(maxFreq, audioContext.currentTime, 0.01);
        } else if (value < 0.5) { 
            filterNode.type = 'lowpass';
            const freq = Math.pow(10, 2 + (value * 2) * 2.5);
            filterNode.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.01);
        } else { 
            filterNode.type = 'highpass';
            const freq = Math.pow(10, 1 + ((value - 0.5) * 2) * 3);
            filterNode.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.01);
        }
    }

    // --- PLAYLIST FUNCTIONS ---
    async function loadFolder() {
        if (!('showDirectoryPicker' in window)) {
            alert('Your browser does not support the Folder Selection API.');
            return;
        }
        try {
            const directoryHandle = await window.showDirectoryPicker();
            playlistFiles = [];
            for await (const entry of directoryHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(mp3|wav|ogg|flac|m4a)$/i)) {
                    playlistFiles.push(entry);
                }
            }
            renderPlaylist();
        } catch (err) {
            // ▼▼▼ ERROR FIX ▼▼▼
            if (err.name === 'AbortError') {
                status.textContent = 'Folder selection cancelled.';
            } else {
                console.error('Folder selection failed:', err);
                status.textContent = 'Error loading folder.';
            }
            // ▲▲▲ ERROR FIX ▲▲▲
        }
    }

    function renderPlaylist() {
        const playlistEl = document.getElementById('playlist');
        playlistEl.innerHTML = '';
        playlistFiles.forEach((fileHandle, index) => {
            const li = document.createElement('li');
            li.textContent = fileHandle.name.replace(/\.[^/.]+$/, "");
            const btnContainer = document.createElement('div');
            btnContainer.className = 'load-track-btns';
            const btnA = document.createElement('button');
            btnA.textContent = 'A';
            btnA.onclick = async () => loadTrack('A', await fileHandle.getFile());
            const btnB = document.createElement('button');
            btnB.textContent = 'B';
            btnB.onclick = async () => loadTrack('B', await fileHandle.getFile());
            btnContainer.appendChild(btnA);
            btnContainer.appendChild(btnB);
            li.appendChild(btnContainer);
            playlistEl.appendChild(li);
        });
    }

    // --- UI & VISUALS ---
    function startVisualUpdates() {
        function updateLoop() {
            ['A', 'B'].forEach(id => {
                if (decks[id].isPlaying) updateProgress(id);
            });
            animationFrameId = requestAnimationFrame(updateLoop);
        }
        updateLoop();
    }
    
    function updateProgress(id) {
        const d = decks[id];
        if (!d.audioBuffer) return;
        const elapsed = d.isPlaying ? audioContext.currentTime - d.startTime : d.cuePoint;
        const progress = (elapsed / d.audioBuffer.duration) * 100;
        document.querySelector(`#deck-${id} .waveform-progress`).style.width = `${Math.min(100, progress)}%`;
    }

    function setupJogWheel(jogEl, id) {
        jogEl.addEventListener('mousedown', e => {
            if (!decks[id].isPlaying || !decks[id].sourceNode) return;
            const initialX = e.clientX;
            const originalRate = decks[id].sourceNode.playbackRate.value;
            function onMouseMove(moveEvent) {
                const deltaX = moveEvent.clientX - initialX;
                const bendAmount = deltaX / 2000;
                if (decks[id].sourceNode) decks[id].sourceNode.playbackRate.value = originalRate + bendAmount;
            }
            function onMouseUp() {
                if (decks[id].sourceNode) decks[id].sourceNode.playbackRate.value = originalRate;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    }

    function setupKnob(canvas, callback) {
        let value = 0.5;
        const ctx = canvas.getContext('2d');
        const draw = () => {
            const angle = (value * 1.5 - 0.75) * Math.PI;
            ctx.clearRect(0, 0, 50, 50);
            ctx.fillStyle = '#2a2e36';
            ctx.beginPath(); ctx.arc(25, 25, 24, 0, 2 * Math.PI); ctx.fill();
            ctx.strokeStyle = '#4c525d'; ctx.lineWidth = 2; ctx.stroke();
            ctx.strokeStyle = '#00aeff';
            ctx.lineWidth = 3; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(25, 25); ctx.lineTo(25 + Math.sin(angle) * 20, 25 - Math.cos(angle) * 20); ctx.stroke();
        };
        const handleInteraction = (e) => {
            e.preventDefault();
            const startY = e.clientY || e.touches[0].clientY;
            const startValue = value;
            const onMove = (moveEvent) => {
                const currentY = moveEvent.clientY || moveEvent.touches[0].clientY;
                const deltaY = startY - currentY;
                value = Math.max(0, Math.min(1, startValue + deltaY / 200));
                draw();
                callback(value);
            };
            const onEnd = () => {
                document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onEnd);
                document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onEnd);
            };
            document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onEnd);
            document.addEventListener('touchmove', onMove); document.addEventListener('touchend', onEnd);
        };
        canvas.addEventListener('mousedown', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction);
        draw();
    }
    
    function drawWaveform(id) {
        const buffer = decks[id].audioBuffer;
        if (!buffer) return;
        const canvas = document.querySelector(`#deck-${id} .waveform-canvas`);
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        const data = buffer.getChannelData(0);
        const step = Math.ceil(data.length / canvas.width);
        const amp = canvas.height / 2;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#00aeff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i < canvas.width; i++) {
            let min = 1.0, max = -1.0;
            for (let j = 0; j < step; j++) {
                const datum = data[(i * step) + j];
                if (datum < min) min = datum;
                if (datum > max) max = datum;
            }
            ctx.moveTo(i, (1 + min) * amp);
            ctx.lineTo(i, (1 + max) * amp);
        }
        ctx.stroke();
    }

    function syncBpmInputs(event, id, updateSlider = true) {
        const newBpm = parseFloat(event.target.value);
        const deckEl = document.getElementById(`deck-${id}`);
        if(updateSlider) deckEl.querySelector('.bpm-slider').value = newBpm;
        deckEl.querySelector('.bpm-input').value = newBpm;
        if(decks[id].isPlaying) updatePlaybackRate(id);
    }

    function updateBpmUI(id, bpm) {
        const deckEl = document.getElementById(`deck-${id}`);
        const bpmInput = deckEl.querySelector('.bpm-input');
        const bpmSlider = deckEl.querySelector('.bpm-slider');
        bpmInput.value = (Math.round(bpm * 10) / 10).toFixed(1);
        const baseBpm = Math.round(bpm);
        bpmSlider.min = baseBpm * 0.8;
        bpmSlider.max = baseBpm * 1.2;
        bpmSlider.value = bpm;
    }

    function enableControls(id, isEnabled) {
        document.querySelectorAll(`#deck-${id} button, #deck-${id} input[type=range], #deck-${id} input[type=number]`).forEach(el => {
            el.disabled = !isEnabled;
        });
    }

    function resetDeck(id) {
        if (decks[id].isPlaying) stopSound(id);
        enableControls(id, false);
        decks[id] = { ...decks[id], isPlaying: false, audioBuffer: null, originalBpm: 0, cuePoint: 0, mainCuePoint: 0, hotcues: [null, null, null], loop: {} };
        updateProgress(id);
        const canvas = document.querySelector(`#deck-${id} .waveform-canvas`);
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        document.querySelectorAll(`#deck-${id} .hot-cue-button`).forEach(btn => btn.style.backgroundColor = '');
        document.querySelector(`#deck-${id} .sync-button`).classList.remove('active');
        document.querySelector(`#deck-${id} .loop-toggle`).classList.remove('active');
    }

    async function analyzeBpm(audioBuffer) {
        const offlineCtx = new OfflineAudioContext(1, audioBuffer.length, audioBuffer.sampleRate);
        const source = offlineCtx.createBufferSource();
        source.buffer = audioBuffer;
        const filter = offlineCtx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 150; filter.Q.value = 1;
        source.connect(filter);
        filter.connect(offlineCtx.destination);
        source.start(0);
        const processedBuffer = await offlineCtx.startRendering();
        const data = processedBuffer.getChannelData(0);
        const getPeaks = (data) => {
            const peaks = []; const threshold = 0.9; let lastPeak = 0;
            for (let i = 1; i < data.length - 1; i++) {
                if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > threshold) {
                    if (i - lastPeak > audioBuffer.sampleRate * 0.25) {
                        peaks.push(i);
                        lastPeak = i;
                    }
                }
            }
            return peaks;
        };
        const peaks = getPeaks(data);
        if (peaks.length < 10) return 120;
        const intervals = [];
        for (let i = 0; i < peaks.length - 1; i++) intervals.push(peaks[i + 1] - peaks[i]);
        const tempoCounts = {};
        intervals.forEach(interval => {
            let tempo = 60 / (interval / audioBuffer.sampleRate);
            while (tempo < 80) tempo *= 2;
            while (tempo > 160) tempo /= 2;
            const roundedTempo = Math.round(tempo);
            tempoCounts[roundedTempo] = (tempoCounts[roundedTempo] || 0) + 1;
        });
        if (Object.keys(tempoCounts).length === 0) return 120;
        return parseFloat(Object.keys(tempoCounts).reduce((a, b) => tempoCounts[a] > tempoCounts[b] ? a : b));
    }
</script>
</body>
</html>
